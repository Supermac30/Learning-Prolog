# Definite Clause Grammars

## Context Free Grammars

A grammar is a collection of rules that explain what to substitue to create a sentence.
A language is a collection of all sentences that can be created through a grammar.

A context free grammar uses non-terminal symbols to allow for 
further substitutions and terminal symbols that create the string, called the alphabet (or lexical terms by linguists).
There exists a start variable in a grammar where substitutions begin.

We can build a parse tree for every string created by the grammar where the 
tree is built up depending on the rules we choose.

A context free recogniser is a program that checks if a string
can be created by a grammar.

## CFGs in Prolog

We can turn the following grammar into prolog easily using the append method.

S  ->  NP  VP
NP  ->  DET N
VP  ->  V  NP
VP  ->  V
DET  -> a
DET  -> the
n  -> woman
n  -> man
v  -> shoots

This becomes:

s(Z):-  np(X),  vp(Y),  append(X,Y,Z).
np(Z):-  det(X),  n(Y),  append(X,Y,Z).
vp(Z):-  v(X),  np(Y),  append(X,Y,Z).
vp(Z):-  v(Z).
det([the]).
det([a]).
n([woman]).
n([man]).
v([shoots]).

We can now ask prolog to generate the language with ?- s(X).

This is inefficient, however, as when given a string prolog 
tries to generate all possible strings and compares it to the input.

## CFGs With Difference Lists

A more efficient implementation of this can be created with a difference list.
The key idea is to represent the information as the difference between two
lists.

e.g [a,woman,shoots,a,man]  [].

We are essentially telling prolog that if we remove the elements from the 
left and leave the symbols on the right we get the sentence we want to query.

Using a differnce list we can rewrite the grammar above as:

s(X,Z):-  np(X,Y), vp(Y,Z).
np(X,Z):-  det(X,Y), n(Y,Z).
vp(X,Z):-  v(X,Y), np(Y,Z).
vp(X,Z):-  v(X,Z).
det([the|W],W).
det([a|W],W).
n([woman|W],W).
n([man|W],W).
v([shoots|W],W).

This works by splitting the string into two parts. Each predicate
that isn't the end considers the left and right part individually.
Once a terminal variable is reached notice how the second part is 
added to the list, terminal([word| W], W). This means that the right 
part of any non-terminal variable will be added to the left part of 
any nonterminal variable. nonTerminal(X, Z) :- left(X, Y), right(Y, Z).
The Y variable ensures that the part that is added onto X is the same 
as the part generated by the right.

To use this to generate the language we can simply query ?- s(X, []).

## Definite Clause Grammars

Prolog has a built in method of handeling grammars.
The grammar above can be rewritten as:

s  -->  np,vp.
np  -->  det,n.
vp  -->  v,np.
vp  -->  v.
det  -->  [the].
det  -->  [a].
n  -->  [woman].
n  -->  [man].
v  -->  [shoots].

To use the DCG we can use the same query as before ?- s(X, []).
The queries don't have to be about the start variable, e.g. 
?- np(X, []).

Using the built in predicate listing\2 we can see that, 
internally, prolog stores a grammar using a difference list.
To get a complete listsing of the rules we can write ?- listing.

We can use recursive rules to generate languages of infinite 
lengths. Notice, however, that left recursive rules can lead 
to infinite loops and as such we must work around them when 
building DCGs.